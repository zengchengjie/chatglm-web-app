# Java单元测试教学指南

## 目录
1. [单元测试概述](#单元测试概述)
2. [单元测试框架](#单元测试框架)
3. [常用单元测试场景](#常用单元测试场景)
4. [测试覆盖率](#测试覆盖率)
5. [单元测试最佳实践](#单元测试最佳实践)
6. [常见陷阱与注意事项](#常见陷阱与注意事项)
7. [进阶技巧](#进阶技巧)

## 单元测试概述

### 什么是单元测试
单元测试是针对程序中最小可测试单元（通常是一个方法或类）进行的测试。它是软件测试的基础，能够帮助开发者：
- 验证代码的正确性
- 提高代码质量
- 促进重构和优化
- 作为代码文档

### 单元测试的重要性
1. **早期发现问题**：在开发阶段就能发现并修复问题
2. **降低修复成本**：问题发现越早，修复成本越低
3. **提供安全网**：为重构和代码修改提供保障
4. **促进设计**：编写可测试的代码通常意味着更好的设计

## 单元测试框架

### JUnit 5
JUnit是Java最流行的单元测试框架，JUnit 5是最新版本，由三个模块组成：
- **JUnit Platform**：提供测试运行的基础设施
- **JUnit Jupiter**：提供新的编程模型和扩展模型
- **JUnit Vintage**：支持运行JUnit 3和4的测试

### 基本测试结构
```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class CalculatorTest {
    @Test
    void add() {
        Calculator calculator = new Calculator();
        int result = calculator.add(2, 3);
        assertEquals(5, result, "2 + 3 应该等于 5");
    }
}
```

### 常用注解
- `@Test`：标记一个测试方法
- `@BeforeEach`：在每个测试方法执行前运行
- `@AfterEach`：在每个测试方法执行后运行
- `@BeforeAll`：在所有测试方法执行前运行一次（静态方法）
- `@AfterAll`：在所有测试方法执行后运行一次（静态方法）
- `@DisplayName`：为测试类或方法提供自定义显示名称
- `@Disabled`：禁用测试类或方法

## 常用单元测试场景

### 1. 基本功能测试
测试方法的基本功能是否正确：

```java
@Test
@DisplayName("测试字符串反转")
void testReverseString() {
    StringReverser reverser = new StringReverser();
    assertEquals("cba", reverser.reverse("abc"));
    assertEquals("", reverser.reverse(""));
    assertEquals("a", reverser.reverse("a"));
}
```

### 2. 边界条件测试
测试边界值和极端情况：

```java
@Test
@DisplayName("测试边界条件")
void testBoundaryConditions() {
    ScoreCalculator calculator = new ScoreCalculator();

    // 测试最小值
    assertEquals(0, calculator.calculate(-1));

    // 测试最大值
    assertEquals(100, calculator.calculate(101));

    // 测试临界点
    assertEquals(50, calculator.calculate(50));
}
```

### 3. 异常处理测试
验证方法是否在预期情况下抛出正确的异常：

```java
@Test
@DisplayName("测试异常处理")
void testExceptionHandling() {
    DataProcessor processor = new DataProcessor();

    // 测试是否抛出预期异常
    assertThrows(IllegalArgumentException.class, () -> {
        processor.process(null);
    });

    // 测试异常消息
    Exception exception = assertThrows(IllegalArgumentException.class, () -> {
        processor.process("");
    });
    assertEquals("输入不能为空", exception.getMessage());
}
```

### 4. Mock对象测试
使用Mock对象隔离依赖：

```java
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import static org.mockito.Mockito.*;

@Test
@DisplayName("测试使用Mock对象")
void testWithMock() {
    // 创建Mock对象
    UserRepository mockRepo = mock(UserRepository.class);

    // 设置Mock行为
    when(mockRepo.findById(1L)).thenReturn(Optional.of(new User("张三")));

    // 使用Mock对象进行测试
    UserService userService = new UserService(mockRepo);
    User user = userService.getUserById(1L);

    // 验证结果
    assertEquals("张三", user.getName());

    // 验证Mock交互
    verify(mockRepo).findById(1L);
}
```

### 5. 集成测试
测试多个组件的协作：

```java
@SpringBootTest
@TestPropertySource(locations = "classpath:application-test.properties")
@TestMethodOrder(OrderAnnotation.class)
class UserServiceIntegrationTest {

    @Autowired
    private UserService userService;

    @Test
    @Order(1)
    @DisplayName("测试用户创建")
    void testCreateUser() {
        User user = new User("测试用户", "test@example.com");
        User savedUser = userService.save(user);

        assertNotNull(savedUser.getId());
        assertEquals("测试用户", savedUser.getName());
    }

    @Test
    @Order(2)
    @DisplayName("测试用户查询")
    void testFindUser() {
        List<User> users = userService.findByName("测试用户");

        assertFalse(users.isEmpty());
        assertEquals("测试用户", users.get(0).getName());
    }
}
```

### 6. 参数化测试
使用不同参数运行同一测试：

```java
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.junit.jupiter.params.provider.CsvSource;

@ParameterizedTest
@ValueSource(strings = {"racecar", "level", "madam"})
@DisplayName("参数化测试回文")
void testPalindrome(String word) {
    assertTrue(StringUtils.isPalindrome(word));
}

@ParameterizedTest
@CsvSource({
    "1, 1, 2",
    "2, 3, 5",
    "5, 8, 13"
})
@DisplayName("参数化测试斐波那契数列")
void testFibonacci(int a, int b, int expected) {
    assertEquals(expected, FibonacciCalculator.next(a, b));
}
```

### 7. 性能测试
测试方法的执行时间：

```java
@Test
@DisplayName("测试性能")
void testPerformance() {
    DataSorter sorter = new DataSorter();
    int[] data = generateLargeDataSet(100000);

    // 使用断言超时
    assertTimeout(Duration.ofSeconds(5), () -> {
        sorter.sort(data);
    });

    // 或者使用计时器
    long startTime = System.currentTimeMillis();
    sorter.sort(data);
    long endTime = System.currentTimeMillis();

    assertTrue((endTime - startTime) < 5000, "排序应在5秒内完成");
}
```

## 测试覆盖率

### 什么是测试覆盖率
测试覆盖率是衡量测试完整性的指标，表示代码被测试执行的程度。常见的覆盖率指标包括：
- **行覆盖率**：代码行被执行的比例
- **分支覆盖率**：条件分支被执行的比例
- **方法覆盖率**：方法被调用的比例
- **类覆盖率**：类被实例化的比例

### 如何查看测试覆盖率
使用JaCoCo插件可以方便地查看测试覆盖率：

```xml
<!-- 在pom.xml中添加JaCoCo插件 -->
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.7</version>
    <executions>
        <execution>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>report</id>
            <phase>test</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

运行测试后，覆盖率报告将生成在`target/site/jacoco/index.html`。

### 合理的覆盖率目标
- 核心业务逻辑：80-100%
- 工具类：90-100%
- 复杂算法：100%
- 简单Getter/Setter：0-30%（可忽略）
- 整体项目：70-80%

## 单元测试最佳实践

### 1. 命名规范
测试方法名应清晰表达测试内容：
```java
// 不好的命名
@Test
void test1() { ... }

// 好的命名
@Test
void should_ReturnCorrectValue_When_ValidInputProvided() { ... }
```

### 2. 测试结构
遵循AAA模式（Arrange-Act-Assert）：
```java
@Test
void should_CalculateDiscount_When_PremiumCustomer() {
    // Arrange - 准备测试数据
    Customer customer = new Customer("张三", CustomerType.PREMIUM);
    Product product = new Product("笔记本电脑", 10000);

    // Act - 执行被测试的方法
    BigDecimal discount = discountCalculator.calculate(customer, product);

    // Assert - 验证结果
    assertEquals(new BigDecimal("1000"), discount);
}
```

### 3. 测试隔离
每个测试应该独立运行，不依赖其他测试的状态：
```java
// 不好的做法 - 测试之间有依赖关系
@Test
void testCreateUser() {
    userService.createUser("张三");
}

@Test
void testFindUser() {
    // 依赖上一个测试创建的用户
    User user = userService.findByName("张三");
    assertNotNull(user);
}

// 好的做法 - 每个测试独立
@Test
void testCreateUser() {
    User user = userService.createUser("张三");
    assertNotNull(user.getId());
}

@Test
void testFindUser() {
    // 在当前测试中创建所需数据
    User createdUser = userService.createUser("张三");
    User foundUser = userService.findByName("张三");
    assertEquals(createdUser.getId(), foundUser.getId());
}
```

### 4. 测试数据管理
使用测试专用数据，避免依赖生产数据：
```java
// 使用测试专用的配置文件
@TestPropertySource(locations = "classpath:application-test.properties")

// 使用内存数据库进行测试
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class UserRepositoryTest {
    // 测试代码
}
```

### 5. 断言使用
使用具体、有意义的断言：
```java
// 不好的做法
assertTrue(result != null);

// 好的做法
assertNotNull(result, "结果不应为空");
assertEquals("预期值", result, "结果应等于预期值");
```

## 常见陷阱与注意事项

### 1. 测试实现细节而非行为
```java
// 不好的做法 - 测试实现细节
@Test
void testInternalList() {
    MyClass obj = new MyClass();
    List<String> list = obj.getInternalList();
    assertEquals(0, list.size()); // 依赖于内部实现
}

// 好的做法 - 测试行为
@Test
void testAddItem() {
    MyClass obj = new MyClass();
    obj.addItem("item");
    assertTrue(obj.containsItem("item")); // 测试公共行为
}
```

### 2. 过度使用Mock
```java
// 不好的做法 - 过度Mock
@Test
void testService() {
    // Mock所有依赖，包括简单对象
    DataProcessor mockProcessor = mock(DataProcessor.class);
    DataValidator mockValidator = mock(DataValidator.class);
    DataFormatter mockFormatter = mock(DataFormatter.class);

    // 设置大量Mock行为
    when(mockProcessor.process(any())).thenReturn("processed");
    when(mockValidator.validate(any())).thenReturn(true);
    when(mockFormatter.format(any())).thenReturn("formatted");

    // 测试代码
}

// 好的做法 - 只Mock必要的依赖
@Test
void testService() {
    // 只Mock外部依赖
    ExternalService mockService = mock(ExternalService.class);
    when(mockService.callApi(any())).thenReturn(apiResponse);

    // 使用真实对象进行内部逻辑测试
    DataProcessor processor = new DataProcessor();
    // 测试代码
}
```

### 3. 测试过于复杂
```java
// 不好的做法 - 测试逻辑复杂
@Test
void testComplexScenario() {
    // 复杂的设置
    // 大量条件判断
    // 多个断言
    // 难以理解和维护
}

// 好的做法 - 拆分为多个简单测试
@Test
void testSimpleScenario1() {
    // 简单的设置
    // 单一关注点
    // 清晰的断言
}

@Test
void testSimpleScenario2() {
    // 另一个简单场景
}
```

### 4. 忽略异常处理
```java
// 不好的做法 - 不测试异常情况
@Test
void testNormalFlow() {
    // 只测试正常流程
}

// 好的做法 - 测试正常和异常情况
@Test
void testNormalFlow() {
    // 测试正常流程
}

@Test
void testExceptionFlow() {
    // 测试异常情况
    assertThrows(BusinessException.class, () -> {
        // 触发异常的代码
    });
}
```

### 5. 测试环境不一致
```java
// 不好的做法 - 依赖特定环境
@Test
void testWithFile() {
    // 依赖特定文件路径
    File file = new File("/home/user/data.txt");
    // 测试代码
}

// 好的做法 - 使用资源或Mock
@Test
void testWithResource() {
    // 使用类路径资源
    InputStream stream = getClass().getResourceAsStream("/data.txt");
    // 测试代码
}
```

## 进阶技巧

### 1. 自定义断言
创建领域特定的断言方法：
```java
public class UserAssert {
    private User user;

    private UserAssert(User user) {
        this.user = user;
    }

    public static UserAssert assertThat(User user) {
        return new UserAssert(user);
    }

    public UserAssert hasName(String expectedName) {
        assertEquals(expectedName, user.getName());
        return this;
    }

    public UserAssert isActive() {
        assertTrue(user.isActive());
        return this;
    }
}

// 使用自定义断言
@Test
void testUserCreation() {
    User user = userService.createUser("张三");
    UserAssert.assertThat(user)
        .hasName("张三")
        .isActive();
}
```

### 2. 测试规则
使用JUnit扩展创建可重用的测试规则：
```java
import org.junit.jupiter.api.extension.ExtendWith;

@ExtendWith(DatabaseCleanupExtension.class)
class UserRepositoryTest {
    // 测试代码
}

public class DatabaseCleanupExtension implements BeforeEachCallback, AfterEachCallback {
    @Override
    public void beforeEach(ExtensionContext context) {
        // 测试前清理数据库
    }

    @Override
    public void afterEach(ExtensionContext context) {
        // 测试后清理数据库
    }
}
```

### 3. 测试模板
使用@TestTemplate创建可执行多次的测试：
```java
@TestTemplate
@ExtendWith(MyTestTemplateInvocationContextProvider.class)
void testTemplate(String parameter) {
    // 使用不同参数执行测试
}

public class MyTestTemplateInvocationContextProvider implements TestTemplateInvocationContextProvider {
    // 提供测试执行上下文
}
```

### 4. 动态测试
运行时生成测试用例：
```java
@TestFactory
Collection<DynamicTest> dynamicTests() {
    List<DynamicTest> tests = new ArrayList<>();

    // 从数据源加载测试数据
    List<TestCase> testCases = loadTestCases();

    for (TestCase testCase : testCases) {
        tests.add(DynamicTest.dynamicTest(
            "测试: " + testCase.getName(),
            () -> {
                // 执行测试
                assertTrue(executeTest(testCase));
            }
        ));
    }

    return tests;
}
```

### 5. 并行测试
并行执行测试以提高效率：
```java
// 在junit-platform.properties中配置
junit.jupiter.execution.parallel.enabled = true
junit.jupiter.execution.parallel.mode.default = concurrent

// 在测试类上指定并行模式
@Execution(ExecutionMode.CONCURRENT)
class ParallelTest {
    // 测试方法将并行执行
}
```

## 总结

单元测试是软件开发中不可或缺的一部分，它能够提高代码质量、降低维护成本并促进良好的设计。通过遵循本文档中的最佳实践和注意事项，您可以编写出高效、可靠且易于维护的单元测试。

记住，好的单元测试应该：
- **快速**：执行速度快，不拖慢开发流程
- **独立**：不依赖其他测试或外部系统
- **可重复**：每次运行结果一致
- **自验证**：自动判断测试通过或失败
- **及时**：在适当的时间编写（通常是编码后立即编写）

持续改进您的单元测试技能，将使您成为更优秀的开发者。
