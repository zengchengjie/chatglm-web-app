# 参数化测试详解

## 什么是参数化测试

参数化测试是一种测试方法，允许您使用不同的输入参数多次运行同一个测试方法。这样可以避免编写大量重复的测试代码，同时能够更全面地测试各种输入情况。

## 为什么使用参数化测试

1. **减少代码重复**：避免为不同输入编写相似的测试方法
2. **提高测试覆盖率**：轻松测试多种输入情况，包括边界值和异常情况
3. **提高可维护性**：添加新的测试用例只需添加参数，无需编写新方法
4. **增强可读性**：测试数据和测试逻辑分离，更易于理解

## JUnit 5 参数化测试基础

### 必要依赖

首先，确保您的项目中包含JUnit Jupiter参数化测试的依赖：

```xml
<!-- Maven依赖 -->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-params</artifactId>
    <version>5.8.2</version>
    <scope>test</scope>
</dependency>
```

### 基本结构

参数化测试使用`@ParameterizedTest`注解代替`@Test`，并配合一个"源"注解提供测试参数：

```java
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

@ParameterizedTest
@ValueSource(ints = {1, 2, 3})
void testWithValues(int value) {
    // 测试逻辑
    assertTrue(value > 0);
}
```

## 常用参数源

### 1. @ValueSource

最简单的参数源，支持基本类型和String：

```java
@ParameterizedTest
@ValueSource(strings = {"racecar", "level", "madam"})
void testPalindrome(String word) {
    assertTrue(StringUtils.isPalindrome(word));
}

@ParameterizedTest
@ValueSource(ints = {1, 2, 3, 4, 5})
void testIsPositive(int number) {
    assertTrue(number > 0);
}

@ParameterizedTest
@ValueSource(doubles = {0.0, Math.PI, Math.E})
void testMathConstants(double value) {
    assertFalse(Double.isNaN(value));
}
```

### 2. @EnumSource

使用枚举值作为参数：

```java
enum Direction {
    NORTH, SOUTH, EAST, WEST
}

@ParameterizedTest
@EnumSource(Direction.class)
void testDirection(Direction direction) {
    assertNotNull(direction);
}

// 可以指定特定的枚举值
@ParameterizedTest
@EnumSource(value = Direction.class, names = {"NORTH", "SOUTH"})
void testCardinalDirections(Direction direction) {
    assertTrue(direction == Direction.NORTH || direction == Direction.SOUTH);
}

// 使用模式匹配
@ParameterizedTest
@EnumSource(value = Direction.class, mode = EnumSource.Mode.MATCH_ALL, names = "^.*TH$")
void testDirectionsEndingWithTh(Direction direction) {
    assertTrue(direction.name().endsWith("TH"));
}
```

### 3. @MethodSource

使用工厂方法提供参数：

```java
@ParameterizedTest
@MethodSource("stringProvider")
void testWithMethodSource(String argument) {
    assertNotNull(argument);
}

static Stream<String> stringProvider() {
    return Stream.of("apple", "banana", "cherry");
}

// 提供多个参数
@ParameterizedTest
@MethodSource("stringIntAndListProvider")
void testWithMultiArgMethodSource(String str, int num, List<String> list) {
    assertEquals(3, str.length());
    assertTrue(num >=1 && num <=2);
    assertEquals(2, list.size());
}

static Stream<Arguments> stringIntAndListProvider() {
    return Stream.of(
        arguments("foo", 1, Arrays.asList("a", "b")),
        arguments("bar", 2, Arrays.asList("x", "y"))
    );
}
```

### 4. @CsvSource

使用CSV格式的字符串提供参数：

```java
@ParameterizedTest
@CsvSource({
    "apple, 1",
    "banana, 2",
    "'lemon, lime', 3"  // 注意：包含逗号的值需要用引号括起来
})
void testWithCsvSource(String fruit, int rank) {
    assertNotNull(fruit);
    assertTrue(rank >= 1 && rank <= 3);
}

// 使用自定义分隔符
@ParameterizedTest
@CsvSource(value = {
    "apple; RED",
    "banana; YELLOW"
}, delimiter = ';')
void testWithCustomDelimiter(String fruit, String color) {
    assertNotNull(fruit);
    assertNotNull(color);
}
```

### 5. @CsvFileSource

从CSV文件读取参数：

```java
// 假设src/test/resources/data.csv内容：
// apple, RED, 1
// banana, YELLOW, 2

@ParameterizedTest
@CsvFileSource(resources = "/data.csv", numLinesToSkip = 1) // 跳过标题行
void testWithCsvFileSource(String fruit, String color, int rank) {
    assertNotNull(fruit);
    assertNotNull(color);
    assertTrue(rank >= 1);
}
```

### 6. @ArgumentsSource

使用自定义的ArgumentsProvider：

```java
@ParameterizedTest
@ArgumentsSource(CustomArgumentsProvider.class)
void testWithCustomArgumentsProvider(String argument) {
    assertNotNull(argument);
}

static class CustomArgumentsProvider implements ArgumentsProvider {
    @Override
    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
        return Stream.of("apple", "banana").map(Arguments::of);
    }
}
```

## 高级用法

### 1. 参数转换

JUnit 5会自动尝试将参数转换为测试方法参数类型：

```java
@ParameterizedTest
@ValueSource(strings = {"true", "false"})
void testBooleanConversion(Boolean value) {
    // 字符串"true"和"false"会自动转换为Boolean类型
}

@ParameterizedTest
@ValueSource(strings = {"1", "2", "3"})
void testIntegerConversion(Integer value) {
    // 字符串会自动转换为Integer类型
}

// 自定义转换器
@ParameterizedTest
@ValueSource(strings = {"2021-01-01", "2021-12-31"})
void testDateConversion(@ConvertWith(LocalDateConverter.class) LocalDate date) {
    assertNotNull(date);
}

static class LocalDateConverter extends SimpleArgumentConverter {
    @Override
    protected Object convert(Object source, Class<?> targetType) {
        if (source instanceof String && targetType == LocalDate.class) {
            return LocalDate.parse((String) source);
        } else {
            throw new IllegalArgumentException("转换失败: " + source);
        }
    }
}
```

### 2. 参数聚合

使用`@AggregateWith`注解将多个参数聚合为一个对象：

```java
@ParameterizedTest
@CsvSource({
    "John, Doe, 30",
    "Jane, Smith, 25"
})
void testPersonAggregation(@AggregateWith(PersonAggregator.class) Person person) {
    assertNotNull(person);
    assertNotNull(person.getFirstName());
    assertNotNull(person.getLastName());
    assertTrue(person.getAge() > 0);
}

static class PersonAggregator implements ArgumentsAggregator {
    @Override
    public Person aggregateArguments(ArgumentsAccessor accessor, ParameterContext context) {
        return new Person(
            accessor.getString(0),
            accessor.getString(1),
            accessor.getInteger(2)
        );
    }
}
```

### 3. 自定义显示名称

使用`@DisplayName`和参数索引自定义测试显示名称：

```java
@ParameterizedTest(name = "{index} => fruit={0}, color={1}")
@CsvSource({
    "apple, RED",
    "banana, YELLOW"
})
void testWithCustomDisplayName(String fruit, String color) {
    // 测试名称会显示为:
    // 1 => fruit=apple, color=RED
    // 2 => fruit=banana, color=YELLOW
}
```

## 实际应用示例

### 1. 测试边界条件

```java
@ParameterizedTest
@ValueSource(ints = {Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE})
@DisplayName("测试边界条件")
void testBoundaryConditions(int value) {
    if (value < 0) {
        assertTrue(Math.abs(value) > 0);
    } else {
        assertTrue(value >= 0);
    }
}
```

### 2. 测试异常情况

```java
@ParameterizedTest
@ValueSource(strings = {"", "   ", "	
"})
@DisplayName("测试空白输入")
void testBlankInput(String input) {
    assertThrows(IllegalArgumentException.class, () -> {
        processor.process(input);
    });
}
```

### 3. 测试业务规则

```java
@ParameterizedTest
@CsvSource({
    "1000, 0, 1000",
    "1000, 500, 1500",
    "1000, -200, 800"
})
@DisplayName("测试账户余额计算")
void testAccountBalance(int initial, int change, int expected) {
    Account account = new Account(initial);
    account.applyChange(change);
    assertEquals(expected, account.getBalance());
}
```

## 最佳实践

1. **有意义的参数**：确保每个参数代表一个有意义的测试用例
2. **清晰的命名**：使用自定义显示名称使测试结果更易读
3. **边界值测试**：包含边界值和极端情况
4. **避免过多参数**：参数过多可能表示测试过于复杂
5. **组合测试**：对于复杂场景，考虑使用组合测试而非参数化测试

## 常见问题与解决方案

### 1. 参数类型不匹配

```java
// 问题：参数类型不匹配
@ParameterizedTest
@ValueSource(strings = {"1", "2", "3"})
void testWithWrongType(Double value) { // 编译错误，无法从String转换为Double
    // 测试代码
}

// 解决方案：使用正确的类型或添加转换器
@ParameterizedTest
@ValueSource(doubles = {1.0, 2.0, 3.0})
void testWithCorrectType(Double value) {
    // 测试代码
}
```

### 2. 参数源返回null

```java
// 问题：参数源返回null会导致测试失败
static Stream<String> nullProvider() {
    return null; // 这会导致测试失败
}

// 解决方案：确保参数源不为null
static Stream<String> validProvider() {
    return Stream.of("value1", "value2");
}
```

### 3. 测试方法参数过多

```java
// 问题：测试方法参数过多，难以维护
@ParameterizedTest
@CsvSource({
    "1, 2, 3, 4, 5, 6, 7, 8, 9, 10"
})
void testTooManyParameters(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j) {
    // 测试代码
}

// 解决方案：使用参数聚合或对象
@ParameterizedTest
@CsvSource({
    "1, 2, 3, 4, 5, 6, 7, 8, 9, 10"
})
void testWithAggregatedParams(@AggregateWith(TestDataAggregator.class) TestData data) {
    // 测试代码
}
```

## 总结

参数化测试是JUnit 5中一个强大的功能，它允许您使用不同的输入参数多次运行同一个测试方法。通过合理使用各种参数源和高级特性，您可以编写出更加简洁、全面和可维护的测试代码。

掌握参数化测试将帮助您：
- 提高测试效率
- 增加测试覆盖率
- 减少重复代码
- 提高测试可读性

在日常开发中，当您发现需要编写多个相似的测试方法时，就应该考虑使用参数化测试来简化您的测试代码。
